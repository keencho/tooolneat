<!DOCTYPE html>
<html lang="ko">
<head>
<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-8846557285079359"
     crossorigin="anonymous"></script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>픽셀 수리 도구 - Toolneat</title>
  <meta name="description" content="고착된 픽셀(Stuck Pixel)을 수리하는 온라인 도구입니다. 빠르게 깜빡이는 RGB 색상 박스를 드래그하여 불량 화소 위에 놓고 10-30분간 실행하면 픽셀이 복구될 수 있습니다. 스턱픽셀(특정 색에 고착된 픽셀)은 높은 확률로 복구됩니다.">
  <meta name="theme-color" content="#2563eb">

  <link rel="canonical" href="https://toolneat.com/tools/life/pixel-fixer/">
  <link rel="alternate" hreflang="ko" href="https://toolneat.com/tools/life/pixel-fixer/">
  <link rel="alternate" hreflang="en" href="https://toolneat.com/en/tools/life/pixel-fixer/">
  <link rel="alternate" hreflang="x-default" href="https://toolneat.com/tools/life/pixel-fixer/">

  <meta property="og:title" content="픽셀 수리 도구 - Toolneat">
  <meta property="og:description" content="스턱픽셀(stuck pixel)을 수리하기 위한 무료 온라인 도구입니다.">
  <meta property="og:url" content="https://toolneat.com/tools/life/pixel-fixer/">
  <meta property="og:type" content="website">

    <link rel="icon" href="/favicon.ico" sizes="48x48">
  <link rel="icon" type="image/svg+xml" href="/assets/icons/favicon.svg">
  <link rel="icon" type="image/png" sizes="32x32" href="/assets/icons/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/assets/icons/favicon-16x16.png">
  <link rel="stylesheet" href="../../../assets/css/output.css">

  <script src="../../../assets/js/common.js"></script>
  <script src="../../../assets/js/i18n.js"></script>
  <script src="../../../assets/js/components.js"></script>
  <style>
    #fixer-box {
      position: absolute;
      width: 200px;
      height: 200px;
      cursor: move;
      border: 2px solid rgba(255,255,255,0.5);
      border-radius: 4px;
      box-shadow: 0 0 20px rgba(0,0,0,0.5);
      overflow: hidden;
    }
    #fixer-box canvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #fixer-container {
      position: relative;
      width: 100%;
      height: 400px;
      background: #1a1a1a;
      border-radius: 12px;
      overflow: hidden;
    }
    #fullscreen-overlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: none;
      background: #000;
    }
    #fullscreen-overlay.active {
      display: block;
    }
    #fullscreen-fixer {
      position: absolute;
      width: 200px;
      height: 200px;
      cursor: move;
      border: 2px solid rgba(255,255,255,0.3);
      border-radius: 4px;
      overflow: hidden;
    }
    #fullscreen-fixer canvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
    }
    #fullscreen-hint {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 14px;
      opacity: 1;
      transition: opacity 0.3s;
      z-index: 10;
      white-space: nowrap;
    }
    #fullscreen-overlay:not(:hover) #fullscreen-hint {
      opacity: 0;
    }
    #timer-display {
      position: absolute;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(0,0,0,0.8);
      color: white;
      padding: 8px 16px;
      border-radius: 8px;
      font-size: 16px;
      font-family: monospace;
      z-index: 10;
    }
    .size-btn.active {
      ring-width: 2px;
      --tw-ring-color: #3b82f6;
    }
  </style>
</head>
<body class="min-h-screen flex flex-col">
  <div id="header"></div>

  <main class="flex-1 py-8 md:py-12">
    <div class="container-main">
      <!-- Page Title -->
      <div class="mb-6">
        <h1 class="text-2xl md:text-3xl font-bold text-gray-900 dark:text-white mb-2">
          픽셀 수리 도구
        </h1>
        <p class="text-gray-600 dark:text-gray-400">
          스턱픽셀(stuck pixel)을 수리하기 위한 도구입니다. 박스를 불량 픽셀 위치로 드래그하고 최소 10~20분 이상 실행하세요.
        </p>
      </div>

      <!-- Ad Container (Top) -->
      <div class="ad-container mb-6"></div>

      <!-- Tool Card -->
      <div class="card">
        <!-- Options -->
        <div class="flex flex-wrap gap-4 mb-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 dark:text-gray-300 mb-2">크기</label>
            <div class="flex gap-2">
              <button onclick="setSize(100)" class="size-btn px-3 py-2 bg-gray-100 dark:bg-gray-700 rounded-lg text-sm hover:bg-gray-200 dark:hover:bg-gray-600">100px</button>
              <button onclick="setSize(200)" class="size-btn px-3 py-2 bg-gray-100 dark:bg-gray-700 rounded-lg text-sm hover:bg-gray-200 dark:hover:bg-gray-600 ring-2 ring-blue-500">200px</button>
              <button onclick="setSize(300)" class="size-btn px-3 py-2 bg-gray-100 dark:bg-gray-700 rounded-lg text-sm hover:bg-gray-200 dark:hover:bg-gray-600">300px</button>
            </div>
          </div>
        </div>

        <!-- Preview Container -->
        <div id="fixer-container" class="mb-4">
          <div id="fixer-box">
            <canvas id="preview-canvas"></canvas>
          </div>
          <div class="absolute bottom-3 left-3 text-white/60 text-sm">박스를 드래그하여 위치 조정</div>
        </div>

        <!-- Buttons -->
        <div class="flex flex-wrap gap-3">
          <button onclick="startFullscreen()" class="px-6 py-3 bg-blue-600 hover:bg-blue-700 text-white font-medium rounded-xl transition-colors">
            전체화면으로 실행
          </button>
          <button onclick="togglePreview()" id="preview-btn" class="px-6 py-3 bg-gray-600 hover:bg-gray-700 text-white font-medium rounded-xl transition-colors">
            미리보기 시작
          </button>
        </div>
      </div>

      <!-- Info Section -->
      <div class="mt-8 p-6 bg-blue-50 dark:bg-blue-900/20 rounded-xl">
        <h2 class="text-lg font-semibold text-gray-900 dark:text-white mb-3">스턱픽셀이란?</h2>
        <div class="text-gray-600 dark:text-gray-400 space-y-2">
          <p><strong>스턱픽셀(Stuck Pixel)</strong>은 특정 색상(빨강, 초록, 파랑 중 하나)에서 멈춰버린 픽셀입니다. 완전히 꺼진 <strong>데드픽셀</strong>과 달리, 소프트웨어로 수리 가능성이 있습니다.</p>
          <p><strong>수리 원리</strong>: 빠르게 변하는 랜덤 색상으로 픽셀의 트랜지스터를 자극하여 정상 작동하도록 유도합니다. 대부분의 스턱픽셀은 10~20분 내에 복구됩니다.</p>
        </div>

        <h3 class="font-semibold text-gray-900 dark:text-white mt-5 mb-2">다른 수리 방법</h3>
        <div class="text-gray-600 dark:text-gray-400 space-y-2 text-sm">
          <p><strong>압력/마사지 방법</strong>: 부드러운 천으로 해당 부위를 살살 문지르거나 누릅니다. 액정 내 액체가 퍼지도록 도와줍니다. 이 도구를 실행하면서 함께 하면 효과적입니다.</p>
          <p><strong>전원 끄고 휴식</strong>: 모니터를 끄고 24시간 이상 방치합니다. 과사용으로 인한 문제는 자연 복구되기도 합니다.</p>
          <p><strong>기다리기</strong>: 스턱픽셀은 시간이 지나면 저절로 고쳐지는 경우가 많습니다.</p>
        </div>

        <div class="mt-4 p-3 bg-yellow-100 dark:bg-yellow-900/30 rounded-lg">
          <p class="text-sm text-yellow-800 dark:text-yellow-200"><strong>주의:</strong> 이 도구는 <strong>스턱픽셀</strong>에만 효과가 있습니다. 물리적으로 손상된 <strong>데드픽셀</strong>(완전히 검은 점)은 소프트웨어로 수리할 수 없습니다.</p>
        </div>
      </div>

      <!-- Description Section -->
      <section class="mt-8 bg-white dark:bg-gray-800 rounded-2xl p-6 shadow-sm border border-gray-100 dark:border-gray-700">
        <h2 class="text-xl font-bold text-gray-900 dark:text-white mb-4">픽셀 수리 도구란?</h2>
        <div class="prose prose-gray dark:prose-invert max-w-none text-sm">
          <p>픽셀 수리 도구는 스턱픽셀(stuck pixel)을 수리하기 위한 온라인 도구입니다. 빠르게 변하는 랜덤 색상(노이즈)으로 멈춘 픽셀의 트랜지스터를 자극하여 정상 작동하도록 유도합니다.</p>
          <p class="mt-3">JScreenFix와 같은 원리로 작동하며, 대부분의 스턱픽셀은 10~20분 정도 실행하면 복구됩니다. 데드픽셀(완전히 꺼진 픽셀)은 물리적 손상이므로 이 도구로 수리할 수 없습니다.</p>

          <h3 class="text-lg font-semibold mt-6 mb-3">사용 방법</h3>
          <ol class="list-decimal list-inside space-y-2">
            <li>먼저 불량화소 테스트로 스턱픽셀의 정확한 위치를 파악합니다</li>
            <li>수리 박스의 크기를 선택합니다 (100px, 200px, 300px)</li>
            <li>박스를 스턱픽셀 위치로 드래그합니다</li>
            <li>'전체화면으로 실행' 버튼을 클릭합니다</li>
            <li>최소 10~20분 이상 실행 후 ESC로 종료하고 결과를 확인합니다</li>
          </ol>

          <h3 class="text-lg font-semibold mt-6 mb-3">자주 묻는 질문</h3>
          <div class="space-y-4">
            <div>
              <h4 class="font-medium">Q: 얼마나 오래 실행해야 하나요?</h4>
              <p>일반적으로 10~20분이면 효과가 나타납니다. 1시간까지 실행해도 안 되면 며칠 간격으로 여러 번 시도해보세요. 그래도 안 되면 물리적 손상일 가능성이 높습니다.</p>
            </div>
            <div>
              <h4 class="font-medium">Q: 모든 불량화소를 수리할 수 있나요?</h4>
              <p>스턱픽셀(특정 색상에 고정된 픽셀)만 수리 가능합니다. 데드픽셀(완전히 검은 픽셀)이나 핫픽셀(항상 밝은 픽셀)은 하드웨어 손상이므로 소프트웨어로 수리할 수 없습니다.</p>
            </div>
            <div>
              <h4 class="font-medium">Q: 화면에 해롭지 않나요?</h4>
              <p>정상적인 사용 범위 내에서는 화면에 해롭지 않습니다. 다만, OLED 디스플레이에서 같은 위치에 너무 오래 실행하면 번인 위험이 있으므로 적당한 시간 내에 사용하세요.</p>
            </div>
          </div>
        </div>
      </section>

      <!-- Ad Container (Bottom) -->
      <div class="ad-container mt-8"></div>
    </div>
  </main>

  <div id="footer"></div>

  <!-- Fullscreen Overlay -->
  <div id="fullscreen-overlay">
    <div id="timer-display">00:00</div>
    <div id="fullscreen-fixer">
      <canvas id="fullscreen-canvas"></canvas>
    </div>
    <div id="fullscreen-hint">드래그하여 위치 조정 | ESC로 종료</div>
  </div>

  <script>
    let animationId = null;
    let isRunning = false;
    let boxSize = 200;
    let startTime = null;
    let timerInterval = null;

    const fixerBox = document.getElementById('fixer-box');
    const fixerContainer = document.getElementById('fixer-container');
    const fullscreenOverlay = document.getElementById('fullscreen-overlay');
    const fullscreenFixer = document.getElementById('fullscreen-fixer');
    const timerDisplay = document.getElementById('timer-display');
    const previewBtn = document.getElementById('preview-btn');

    const previewCanvas = document.getElementById('preview-canvas');
    const fullscreenCanvas = document.getElementById('fullscreen-canvas');
    const previewCtx = previewCanvas.getContext('2d');
    const fullscreenCtx = fullscreenCanvas.getContext('2d');

    // Canvas resolution - match actual box size for 1:1 pixel mapping
    previewCanvas.width = boxSize;
    previewCanvas.height = boxSize;
    fullscreenCanvas.width = boxSize;
    fullscreenCanvas.height = boxSize;

    // Initialize position
    fixerBox.style.left = '50%';
    fixerBox.style.top = '50%';
    fixerBox.style.transform = 'translate(-50%, -50%)';
    fullscreenFixer.style.left = '50%';
    fullscreenFixer.style.top = '50%';
    fullscreenFixer.style.transform = 'translate(-50%, -50%)';

    // Static noise animation (like JScreenFix)
    function drawNoise(ctx, width, height) {
      const imageData = ctx.createImageData(width, height);
      const data = imageData.data;

      for (let i = 0; i < data.length; i += 4) {
        data[i] = Math.random() * 256 | 0;     // R
        data[i + 1] = Math.random() * 256 | 0; // G
        data[i + 2] = Math.random() * 256 | 0; // B
        data[i + 3] = 255;                      // A
      }

      ctx.putImageData(imageData, 0, 0);
    }

    function animate(ctx, canvas) {
      function frame() {
        drawNoise(ctx, canvas.width, canvas.height);
        animationId = requestAnimationFrame(frame);
      }
      animationId = requestAnimationFrame(frame);
    }

    function stopAnimation() {
      if (animationId) {
        cancelAnimationFrame(animationId);
        animationId = null;
      }
    }

    function clearCanvas(ctx, canvas) {
      ctx.fillStyle = '#333';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function togglePreview() {
      if (isRunning) {
        stopAnimation();
        clearCanvas(previewCtx, previewCanvas);
        previewBtn.textContent = '미리보기 시작';
        isRunning = false;
      } else {
        animate(previewCtx, previewCanvas);
        previewBtn.textContent = '미리보기 중지';
        isRunning = true;
      }
    }

    function setSize(size) {
      boxSize = size;
      fixerBox.style.width = size + 'px';
      fixerBox.style.height = size + 'px';
      fullscreenFixer.style.width = size + 'px';
      fullscreenFixer.style.height = size + 'px';

      // Update canvas size for 1:1 pixel mapping
      previewCanvas.width = size;
      previewCanvas.height = size;
      fullscreenCanvas.width = size;
      fullscreenCanvas.height = size;

      document.querySelectorAll('.size-btn').forEach(btn => {
        btn.classList.remove('ring-2', 'ring-blue-500');
        if (btn.textContent === size + 'px') {
          btn.classList.add('ring-2', 'ring-blue-500');
        }
      });
    }

    function updateTimer() {
      if (!startTime) return;
      const elapsed = Math.floor((Date.now() - startTime) / 1000);
      const mins = Math.floor(elapsed / 60).toString().padStart(2, '0');
      const secs = (elapsed % 60).toString().padStart(2, '0');
      timerDisplay.textContent = `${mins}:${secs}`;
    }

    function startFullscreen() {
      fullscreenOverlay.classList.add('active');
      if (fullscreenOverlay.requestFullscreen) {
        fullscreenOverlay.requestFullscreen();
      } else if (fullscreenOverlay.webkitRequestFullscreen) {
        fullscreenOverlay.webkitRequestFullscreen();
      }
      animate(fullscreenCtx, fullscreenCanvas);
      startTime = Date.now();
      timerInterval = setInterval(updateTimer, 1000);
    }

    function exitFullscreen() {
      fullscreenOverlay.classList.remove('active');
      stopAnimation();
      clearCanvas(fullscreenCtx, fullscreenCanvas);
      if (document.fullscreenElement) {
        document.exitFullscreen();
      }
      if (timerInterval) {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      startTime = null;
    }

    // Drag functionality
    function makeDraggable(element, container) {
      let isDragging = false;
      let startX, startY, initialLeft, initialTop;

      element.addEventListener('mousedown', (e) => {
        e.preventDefault();
        isDragging = true;
        startX = e.clientX;
        startY = e.clientY;

        // Get current position
        const style = window.getComputedStyle(element);
        if (element.style.transform !== 'none') {
          element.style.transform = 'none';
          const containerRect = container.getBoundingClientRect();
          initialLeft = (containerRect.width - element.offsetWidth) / 2;
          initialTop = (containerRect.height - element.offsetHeight) / 2;
          element.style.left = initialLeft + 'px';
          element.style.top = initialTop + 'px';
        } else {
          initialLeft = parseInt(style.left) || 0;
          initialTop = parseInt(style.top) || 0;
        }
      });

      document.addEventListener('mousemove', (e) => {
        if (!isDragging) return;
        e.preventDefault();

        const containerRect = container.getBoundingClientRect();
        let newLeft = initialLeft + (e.clientX - startX);
        let newTop = initialTop + (e.clientY - startY);

        // Constrain to container
        newLeft = Math.max(0, Math.min(newLeft, containerRect.width - element.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, containerRect.height - element.offsetHeight));

        element.style.left = newLeft + 'px';
        element.style.top = newTop + 'px';
      });

      document.addEventListener('mouseup', () => {
        isDragging = false;
      });

      // Touch support
      element.addEventListener('touchstart', (e) => {
        e.preventDefault();
        isDragging = true;
        const touch = e.touches[0];
        startX = touch.clientX;
        startY = touch.clientY;

        const style = window.getComputedStyle(element);
        if (element.style.transform !== 'none') {
          element.style.transform = 'none';
          const containerRect = container.getBoundingClientRect();
          initialLeft = (containerRect.width - element.offsetWidth) / 2;
          initialTop = (containerRect.height - element.offsetHeight) / 2;
          element.style.left = initialLeft + 'px';
          element.style.top = initialTop + 'px';
        } else {
          initialLeft = parseInt(style.left) || 0;
          initialTop = parseInt(style.top) || 0;
        }
      }, { passive: false });

      document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        const touch = e.touches[0];
        const containerRect = container.getBoundingClientRect();

        let newLeft = initialLeft + (touch.clientX - startX);
        let newTop = initialTop + (touch.clientY - startY);

        newLeft = Math.max(0, Math.min(newLeft, containerRect.width - element.offsetWidth));
        newTop = Math.max(0, Math.min(newTop, containerRect.height - element.offsetHeight));

        element.style.left = newLeft + 'px';
        element.style.top = newTop + 'px';
      }, { passive: true });

      document.addEventListener('touchend', () => {
        isDragging = false;
      });
    }

    makeDraggable(fixerBox, fixerContainer);
    makeDraggable(fullscreenFixer, fullscreenOverlay);

    // Keyboard events
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape' && fullscreenOverlay.classList.contains('active')) {
        exitFullscreen();
      }
    });

    document.addEventListener('fullscreenchange', () => {
      if (!document.fullscreenElement && fullscreenOverlay.classList.contains('active')) {
        exitFullscreen();
      }
    });

    // Initialize
    clearCanvas(previewCtx, previewCanvas);
    clearCanvas(fullscreenCtx, fullscreenCanvas);
  </script>
</body>
</html>
